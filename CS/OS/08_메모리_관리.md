# 08. 메모리 관리

## 목차

- [Logical vs Physical address](#logical-vs-physical-address)
- [Address Binding](#address-binding)
  * [MMU](#mmu)
- [용어 설명](#-----)
  * [Dynamic Loading](#dynamic-loading)
  * [Overlays](#overlays)
  * [Swapping](#swapping)
  * [Dynamic Linking](#dynamic-linking)
- [Allocation of Physical Memory](#allocation-of-physical-memory)
  * [Contiquous allocation (연속 할당)](#contiquous-allocation--------)
    + [Hole](#hole)
    + [Dynamic Storage-Allocation Problem](#dynamic-storage-allocation-problem)
  * [Noncontiguous allocation (불연속 할당)](#noncontiguous-allocation---------)

## Logical vs Physical address

![image-20220218232722420](08_메모리_관리.assets/image-20220218232722420.png)

* Logical address
  * 가상 메모리 (=virtual address)
* Physical address
  * 메모리의 물리적인 주소

## Address Binding

![image-20220218233129463](08_메모리_관리.assets/image-20220218233129463.png)

![image-20220218233226024](08_메모리_관리.assets/image-20220218233226024.png)

* logical address 가 physical address로 바뀌는 시점이 언제인가?
* Compile time binding
  * 컴파일 시 바인딩 됨
  * 비효율적 (physical address 0번부터 시작하지 않으면 재컴파일 해야함)
  * 현대 운영체제에서 적합하지 않음
* Load time binding
  * 프로그램 실행되는 시점에 바인딩
* Run time binding
  * 실행 시에 물리적인 주소 바인딩 되지만, 수행이 시작된 이후에도 메모리 위치를 옮길 수 있음
  * 바인딩을 점검하는 과정 필요
  * 하드웨어적인 지원 필요 (MMU)

### MMU

![image-20220218235754874](08_메모리_관리.assets/image-20220218235754874.png)

![image-20220218235306932](08_메모리_관리.assets/image-20220218235306932.png)

* 다음과 같은 주소변환 환경에서는 MMU 가 register 2개 필요하다.
  * Relocation register
  * Limit register

![image-20220218235630520](08_메모리_관리.assets/image-20220218235630520.png)



## 용어 설명

### Dynamic Loading

![image-20220218235944349](08_메모리_관리.assets/image-20220218235944349.png)

* 프로세스를 한꺼번에 메모리에 올리는 것이 아니라 해당 루틴이 불릴 때 올리는 것
* 운영체제의 지원 없이 프로그램에서 구현 가능, 현대의 운영체제에서도 메모리를 다 올리지 않고 필요한 부분만 올리지만 운영체제에서 지원한다는 차이가 있음

### Overlays

![image-20220219000426450](08_메모리_관리.assets/image-20220219000426450.png)

* 필요한 부분만을 메모리에 올리는 것
* Dynamic Loading == Overlays

### Swapping

![image-20220219000620615](08_메모리_관리.assets/image-20220219000620615.png)

* 프로세스를 일시적으로 메모리에서 backing store(=swap area)로  **통째로** 쫓아내는 것
* Swap in : Suspended 상태가 됨
* Swap out : Suspended 상태가 풀림
* swaping 을 통해 메모리 공간을 효율적으로 사용하기 위해서는 run time binding 을 지원하는 하드웨어가 더 유리하다.
* swap time은 대부분 데이터가 transfer 되는데 걸리는 시간(transfer time)이다.
  * 데이터의 양이 많기 때문

![image-20220219000726921](08_메모리_관리.assets/image-20220219000726921.png)

### Dynamic Linking

![image-20220219001558880](08_메모리_관리.assets/image-20220219001558880.png)

* linking : 코드와 라이브러리 연결하는 작업
* Dynamic linking
  * linking 을 실행 시간까지 미루는 기법
  * 라이브러리를 찾기 위한 위치정보(stub) 만 실행파일에 포함
  * shared library : dynamic linking을 하는 라이브러리
    * `*.so` : 리눅스
    * `*.dll` : 윈도우

## Allocation of Physical Memory

![image-20220219002219636](08_메모리_관리.assets/image-20220219002219636.png)

### Contiquous allocation (연속 할당)

* 메모리의 연속적인 공간에 적재되는 것
* 💡 ***현대 운영체제는 사용하지 않고 있는 방법***

![image-20220219002451482](08_메모리_관리.assets/image-20220219002451482.png)

![image-20220219002525198](08_메모리_관리.assets/image-20220219002525198.png)

* 고정 분할 방식
  * 내부 조각 : 분할의 크기가 정해져있는데 프로그램의 크기가 더 작아서 자투리 공간이 낭비된다.
  * 외부 조각 : 분할의 크기가 너무 작아서 사용되지 않는 부분이 생긴다.
* 가변 분할 방식
  * 내부 조각으로 인해 낭비될 일이 없음
  * 외부 조각은 여전히 발생 가능함

#### Hole

![image-20220219003108625](08_메모리_관리.assets/image-20220219003108625.png)

#### Dynamic Storage-Allocation Problem

*  비어있는 hole 중 어느곳에 프로세스를 올릴것인지?
* First-fit / Best-fit / Worst-fit
* Compaction
  * hole을 모아서 하나의 큰 block을 만드는 것
  * 비용이 많이 듬

![image-20220219003222610](08_메모리_관리.assets/image-20220219003222610.png)

![image-20220219003549439](08_메모리_관리.assets/image-20220219003549439.png)

### Noncontiguous allocation (불연속 할당)

* 하나의 프로세스가 메모리의 여러 영역에 분산되어 적재되는 것

